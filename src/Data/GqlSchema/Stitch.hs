{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RecordWildCards  #-}
{-# LANGUAGE ScopedTypeVariables  #-}
module Data.GqlSchema.Stitch where

-- bytestring
import qualified Data.ByteString.Char8            as BS
import qualified Data.ByteString.Lazy.Char8       as BL

-- directory
import           System.Directory

-- filepath
import           System.FilePath.Posix

-- graphql-stitch-vomit
import           Data.GqlSchema.Feedback
import           Import

-- lens
import           Control.Lens.Lens
import           Control.Lens.Fold
import           Control.Lens.Operators
import           Control.Lens.Prism

-- morpheus-graphql-core
import           Data.Morpheus.Core
import           Data.Morpheus.Ext.Map
import           Data.Morpheus.Ext.SafeHashMap
import           Data.Morpheus.Types.Internal.AST

-- safe-exceptions
import           Control.Exception.Safe

-- unordered-containers
import qualified Data.HashMap.Strict              as HS

-- text
import qualified Data.Text.Encoding               as TE

class MonadError StitchVomitError m => ManageQuery m where
  stitchSchemas :: Schemas -> m ( Schema VALID )
  readSchemas :: FilePath -> m Schemas
  vomitQuery :: FilePath -> Schema VALID -> m FilePath

type Schemas = [ ByteString ]

-- | Reads all the schemas from the source directory.
readSchemasImpl
  :: ( MonadIO m, MonadError StitchVomitError m )
  => FilePath
  -- ^ Source directory of schema.
  -> m Schemas
readSchemasImpl fp =  do
  filePathRes <- liftIO $ tryAny $ listDirectory fp
  case filePathRes of
    Left _ -> throwError $ StitchVomitError "Invalid source directory path"
    Right filePaths -> do
      res <- liftIO $ fmap ( first ( const $ StitchVomitError "Unable to read schemas" ) )
        . tryAny
        . sequence
        $ BS.readFile <$> ( mkFilePathsValid filePaths )
      liftEither res
  where
    mkFilePathsValid :: [ FilePath ] -> [ FilePath ]
    mkFilePathsValid filePths =
      makeValid
      . (\fps -> fp <> ( pathSeparator : fps ))
      <$> filePths

-- | Vomits all the queries in one file
vomitQueryImpl
  :: ( MonadIO m, MonadError StitchVomitError m )
  => FilePath
  -> Schema VALID
  -> m FilePath
vomitQueryImpl fp schema = do
  writeResponse <- writeSchema fp schema
  absolutePath <- liftIO $ getCurrentDirectory
  either
    (\err -> throwError err)
    ( const $ pure $ absolutePath <> ( pathSeparator : fp ) )
    writeResponse

-- |  Write updated schema to file.
writeSchema
  :: MonadIO m
  => FilePath
  -> Schema VALID
  -> m ( Either StitchVomitError FilePath )
writeSchema fp schema = do
  writeResponse <- liftIO $ tryAny $ BS.writeFile fp ( vomitMessage <> renderSchema schema )
  absolutePath <- liftIO getCurrentDirectory
  pure $ bimap
    ( StitchVomitError . show )
    ( const $ absolutePath <> ( pathSeparator : fp ) )
    writeResponse
  where
    vomitMessage :: ByteString
    vomitMessage = TE.encodeUtf8 $ unlines
      [ "\"\"\""
      , "File generated by Graphql Stitch-Vomit"
      , "\"\"\""
      ]

-- | Stitches all the type Queries, Mutation, and Subscription in one file.
stitchSchemasImpl
  :: MonadError StitchVomitError m
  => Schemas
  -> m ( Schema VALID )
stitchSchemasImpl schemas = liftEither
  . fmap ( updateSchemaSubscription $ parseDocument <$> schemas )
  . fmap ( updateSchemaMutation $ parseDocument <$> schemas )
  . updateSchemaTypes ( parseDocument <$> schemas )
  . appendAllSchemaQueries
  $ parseDocument
  <$> schemas

parseDocument :: ByteString -> Either StitchVomitError ( Schema VALID )
parseDocument = first ( const $ StitchVomitError "Schema parse error" )
  . parseDSL
  . BL.fromStrict

-- | Update schema with the accumulated queries from other graphql files.
appendAllSchemaQueries
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
appendAllSchemaQueries parsedDocs = first ( const $ StitchVomitError "Schema query update error" )
  $ updateSchemaQueryEntries ( mkQueryMapEntries parsedDocs )
  <$> getFirstQuery parsedDocs
  where
    mkQueryMapEntries
      :: [ Either StitchVomitError ( Schema VALID ) ]
      -> HashMap FieldName ( Indexed FieldName ( FieldDefinition OUT VALID ) )
    mkQueryMapEntries pds = pds
      ^.. folded
      . _Right
      . queryL
      . typeContentL
      . objectFieldsL
      . mapEntriesL
      & HS.unions

-- | Update the Mutation field in `Schema`.
updateSchemaMutation
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Schema VALID
  -> Schema VALID
updateSchemaMutation parsedDocs stitchedSchema = stitchedSchema
  & mutationL
  .~ ( stitchMutations parsedDocs ^? _Right . mutationL . _Just )

-- | Update the Subscription field in `Schema`.
updateSchemaSubscription
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Schema VALID
  -> Schema VALID
updateSchemaSubscription parsedDocs stitchedSchema = stitchedSchema
  & subscriptionL
  .~ ( stitchSubscriptions  parsedDocs ^? _Right . subscriptionL . _Just )

-- | Stitch all mutations. This ignores `query` field,
-- it is then used in `updateSchemaMutation` where the mutation field is extracted and
-- appended to the input schema which already has a stitched query.
stitchMutations
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
stitchMutations parsedDocs =
  first ( const $ StitchVomitError "Schema mutation update error" )
  $ updateSchemaMutationEntries ( mkMutationMapEntries parsedDocs )
  <$> getFirstMutation parsedDocs
  where
    mkMutationMapEntries
      :: [ Either StitchVomitError ( Schema VALID ) ]
      -> HashMap FieldName ( Indexed FieldName ( FieldDefinition OUT VALID ) )
    mkMutationMapEntries pds = pds
      ^.. folded
      . _Right
      . mutationL
      . _Just
      . typeContentL
      . objectFieldsL
      . mapEntriesL
      & HS.unions

-- | Stitch all subscriptions. This ignoreds the `query` field,
-- it is used then in `updateSchemaSubscription` where the subscription field is extracted
-- appended to the schema which already has a stitched query.
stitchSubscriptions
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
stitchSubscriptions parsedDocs =
  first ( const $ StitchVomitError "Schema subscription update error" )
  $ updateSchemaSubscriptionEntries ( mkSubscriptionEntries parsedDocs )
  <$> getFirstSubscription parsedDocs
  where
    mkSubscriptionEntries
      :: [ Either StitchVomitError ( Schema VALID ) ]
      -> HashMap FieldName ( Indexed FieldName ( FieldDefinition OUT VALID ) )
    mkSubscriptionEntries pds = pds
      ^.. folded
      . _Right
      . subscriptionL
      . _Just
      . typeContentL
      . objectFieldsL
      . mapEntriesL
      & HS.unions

-- | Filter for type with matching type name. Takes only the matching type name
-- and filters out the rest.
filterSchema
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Text
  -- ^ Type name to match.
  -> ( Schema VALID -> Text )
  -> [ Either StitchVomitError ( Schema VALID ) ]
filterSchema parsedDocs typeNameTxt getTypename =
  foldr ( filterByTypeNameQuery typeNameTxt ) [] parsedDocs
  where
    filterByTypeNameQuery
      :: Text
      -> Either StitchVomitError ( Schema VALID )
      -> [ Either StitchVomitError ( Schema VALID ) ]
      -> [ Either StitchVomitError ( Schema VALID ) ]
    filterByTypeNameQuery typeName pd accum =  case pd of
      Left err -> Left err : accum
      Right schema ->
        if typeName == getTypename schema
        then Right ( mkEmptyTypes schema ) : accum
        else accum

-- | Takes Query and filters out the rest.
filterQuery
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> [ Either StitchVomitError ( Schema VALID ) ]
filterQuery schemas = filterSchema schemas "Query" getQueryTypeName
  where
    getQueryTypeName :: Schema VALID -> Text
    getQueryTypeName schema = schema ^. queryL . typeNameL & readTypeName

-- | Takes Mutation and filters out the rest.
filterMutation
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> [ Either StitchVomitError ( Schema VALID ) ]
filterMutation schemas = filterSchema schemas "Mutation" getMutationTypeName
  where
    getMutationTypeName :: Schema VALID -> Text
    getMutationTypeName schema =  schema
      ^. mutationL
      ^? _Just
      . typeNameL
      . readTypeNameL
      & fromMaybe mempty

-- | Takes Subscription and filters out the rest.
filterSubscription
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> [ Either StitchVomitError ( Schema VALID ) ]
filterSubscription schemas = filterSchema schemas "Subscription" getSubscriptionTypeName
  where
    getSubscriptionTypeName :: Schema VALID -> Text
    getSubscriptionTypeName schema = schema
      ^. subscriptionL
      ^? _Just
      . typeNameL
      . readTypeNameL
      & fromMaybe mempty

-- | Get first matching query. Its purpose is to serve as some sort of accumulator
-- for the rest of the Queries. In other words, get the first query and stick the
-- rest of the matching queries into this one.
getFirstQuery
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
getFirstQuery parsedDocs = maybe
  ( throwError $ StitchVomitError "No Query found." )
  id
  ( getFirstBaseFn filterQuery parsedDocs )


-- | Get first matching mutation. Its purpose is to serve as some sort of accumulator
-- for the rest of the Queries. In other words, get the first mutation and stick the
-- rest of the matching queries into this one.
getFirstMutation
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
getFirstMutation parsedDocs = maybe
  ( throwError $ StitchVomitError "No Mutation found." )
  id
  ( getFirstBaseFn filterMutation parsedDocs )

-- | Get first matching subscription. Its purpose is to serve as some sort of accumulator
-- for the rest of the Queries. In other words, get the first subscription and stick the
-- rest of the matching queries into this one.
getFirstSubscription
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
getFirstSubscription parsedDocs = maybe
  ( throwError $ StitchVomitError "No Subscription found." )
  id
  ( getFirstBaseFn filterSubscription parsedDocs )

-- | Base function for getting first Schema entity/field.
getFirstBaseFn
  :: ( [ Either StitchVomitError ( Schema VALID ) ] -> [a])
  -> [ Either StitchVomitError ( Schema VALID ) ]
  -> Maybe a
getFirstBaseFn filterFn parsedDocs = listToMaybe $ take 1 $ filterFn parsedDocs

-- | Render schema as human readable text.
renderSchema :: ( Schema VALID ) -> ByteString
renderSchema = BL.toStrict . render

updateSchemaQueryEntries
  :: HashMap FieldName ( Indexed FieldName ( FieldDefinition OUT VALID ) )
  -> Schema VALID
  -> Schema VALID
updateSchemaQueryEntries newMapEntries schema = schema
  & queryL
  . typeContentL
  . objectFieldsL
  . mapEntriesL
  .~ newMapEntries

updateSchemaMutationEntries
  :: HashMap FieldName ( Indexed FieldName ( FieldDefinition OUT VALID ) )
  -> Schema VALID
  -> Schema VALID
updateSchemaMutationEntries newMapEntries schema = schema
  & mutationL
  . _Just
  . typeContentL
  . objectFieldsL
  . mapEntriesL
  .~ newMapEntries

updateSchemaSubscriptionEntries
  :: HashMap FieldName ( Indexed FieldName ( FieldDefinition OUT VALID ) )
  -> Schema VALID
  -> Schema VALID
updateSchemaSubscriptionEntries newMapEntries schema = schema
  & subscriptionL
  . _Just
  . typeContentL
  . objectFieldsL
  . mapEntriesL
  .~ newMapEntries

-- | Empty the types field.
mkEmptyTypes :: Schema s -> Schema s
mkEmptyTypes s = s & typesL .~ ( unsafeFromList [] )

-- | Updates the types field of `Schema`.
updateSchemaTypes
  :: [ Either StitchVomitError ( Schema VALID ) ]
  -> Either StitchVomitError ( Schema VALID )
  -> Either StitchVomitError ( Schema VALID )
updateSchemaTypes parsedDocs updatedSchema = second
  (\schema -> schema
    & typesL
    .~ ( mkNewTypeLib parsedDocs ))
    updatedSchema
  where
    mkTypeLib
      :: [ Either StitchVomitError ( Schema VALID ) ]
      -> [ TypeLib VALID ]
    mkTypeLib pDocs =
      foldr (\a accum -> either ( const accum ) ( : accum ) $ a )
      [] ( pDocs <&> fmap types )

    mkNewTypeLib
      :: [ Either StitchVomitError ( Schema VALID ) ]
      -> SafeHashMap TypeName ( TypeDefinition ANY VALID )
    mkNewTypeLib pDocs = unsafeFromList
      . HS.toList
      . HS.unions
      $ unsafeToHashMap
      <$> mkTypeLib pDocs

-- * Lens Util

typesL :: Lens' ( Schema a ) ( TypeLib a )
typesL = lens types (\s newTypeLib -> s { types = newTypeLib })

queryL :: Lens' ( Schema VALID ) ( TypeDefinition OBJECT VALID )
queryL = lens query (\q newQuery -> q { query = newQuery })

mutationL :: Lens' ( Schema VALID ) ( Maybe ( TypeDefinition OBJECT VALID ) )
mutationL = lens mutation (\m newMutation -> m { mutation = newMutation })

subscriptionL :: Lens' ( Schema VALID ) ( Maybe ( TypeDefinition OBJECT VALID ) )
subscriptionL = lens subscription (\s newSub -> s { subscription = newSub })

typeNameL :: Lens' ( TypeDefinition a s ) TypeName
typeNameL = lens typeName (\td newTypeName -> td { typeName = newTypeName })

typeContentL :: Lens' ( TypeDefinition a s ) ( TypeContent TRUE a s )
typeContentL = lens typeContent (\s newTypeContent -> s { typeContent = newTypeContent })

objectFieldsL :: Lens' ( TypeContent ( ELEM OBJECT a ) a s ) ( FieldsDefinition OUT s )
objectFieldsL = lens objectFields (\dt newObjectFields -> dt { objectFields = newObjectFields })

mapEntriesL :: Lens' ( OrdMap k a ) ( HashMap k ( Indexed k a ) )
mapEntriesL = lens mapEntries (\om newOrdMap -> om { mapEntries = newOrdMap })

readTypeNameL :: Lens' TypeName Text
readTypeNameL = lens readTypeName (\tn newTypeName -> tn { readTypeName = newTypeName })
